Note<zzz



applyFunArg (FunName s, args, vtab, place, pos) =
  let val tmp = newName "tmpres"
  in appleReg (S, args, tmp, pos) l [Mips MOVE(place, tmp)]
  end

applyFunArg ( Lambda (_, Params, body, lpos))
  let fun bindParams ( ... ) = ...

  val = vtable' = bindParams params args vtable
    tmp = newName "tmpres"
  in compileExp body vtable' tmp @ [Mips MOVE(place, tmp)]
  end

compileExp e vtable place = case e of
  | Map (farg, arr_exp, elm_type, let_type, pos) =>
  .......


val loop_map0 = case getElmSite elm_type of
        One => Mips.LB(nes_new, elm_reg, "0") ::
          applyFunArg('farg, [nes_neg], vtable, nes_neg, pos) @ [Mips.ADDi(elm_new, eml_neg, "1")]

        Four => ....

